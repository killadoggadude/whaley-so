

  const handleDragOver = (e, jobId) => {
    e.preventDefault();
    e.stopPropagation();
    if (!running) setDragOverJobId(jobId);
  };

  const handleDragLeave = () => {
    setDragOverJobId(null);
  };

  const handleDrop = async (e, jobId) => {
    e.preventDefault();
    e.stopPropagation();
    setDragOverJobId(null);

    if (running) return;

    const file = e.dataTransfer.files && e.dataTransfer.files[0];
    if (!file || !file.type.startsWith('image/')) {
      toast.error('Only image files are supported');
      return;
    }

    const tempEvent = { target: { files: [file] } };
    await handlePickerUpload(tempEvent);
  };
"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Progress } from "@/components/ui/progress";
import {
  Plus,
  Trash2,
  Loader2,
  Video,
  AlertCircle,
  CheckCircle2,
  Upload,
  Search,
  Check,
  ImageIcon,
  Play,
  Download,
  Save,
  Mic,
  X,
  Subtitles,
} from "lucide-react";
import { Switch } from "@/components/ui/switch";
import { CaptionCustomizerInline } from "./caption-customizer";
import { DEFAULT_CAPTION_SETTINGS } from "@/lib/caption-styles";
import type { CustomCaptionSettings } from "@/lib/caption-styles";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import { getAssetsAction } from "@/app/dashboard/assets/actions";
import type { AiModelWithImages, AssetWithUrl } from "@/types";

interface BulkTalkingHeadProps {
  aiModels: AiModelWithImages[];
}

interface BulkJob {
  id: string;
  script: string;
  imageId: string | null;
  imageUrl: string | null;
  // Processing state
  status: "pending" | "generating_voice" | "uploading_audio" | "submitting" | "polling" | "captioning" | "completed" | "failed";
  error?: string;
  audioUrl?: string;
  audioSignedUrl?: string;
  taskId?: string;
  videoUrl?: string;
  captionedVideoUrl?: string;
  videoAssetId?: string;
  pollCount?: number;
}

const POLL_INTERVAL_MS = 3000;
const MAX_POLL_ATTEMPTS = 100;

export function BulkTalkingHead({ aiModels }: BulkTalkingHeadProps) {
  // AI model selection (shared across all jobs)
  const voiceModels = aiModels.filter((m) => m.voice_id && m.voice_id.trim());
  const [selectedModelId, setSelectedModelId] = useState<string>("");
  const [resolution, setResolution] = useState("480p");

  // Caption settings (shared)
  const [captionsEnabled, setCaptionsEnabled] = useState(false);
  const [captionSettings, setCaptionSettings] = useState<CustomCaptionSettings>(
    { ...DEFAULT_CAPTION_SETTINGS }
  );

  // Jobs
  const [jobs, setJobs] = useState<BulkJob[]>([
    { id: crypto.randomUUID(), script: "", imageId: null, imageUrl: null, status: "pending" },
  ]);
  const [running, setRunning] = useState(false);
  const pollingRefs = useRef<Map<string, boolean>>(new Map());

  // Image picker dialog
  const [pickerJobId, setPickerJobId] = useState<string | null>(null);
  const [pickerImages, setPickerImages] = useState<AssetWithUrl[]>([]);
  const [pickerTotal, setPickerTotal] = useState(0);
  const [pickerLoading, setPickerLoading] = useState(false);
  const [pickerSearch, setPickerSearch] = useState("");
  const [uploading, setUploading] = useState(false);
  const [dragOverJobId, setDragOverJobId] = useState<string | null>(null);
  const [dragOverJobId, setDragOverJobId] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

    const [dragOverJobId, setDragOverJobId] = useState<string | null>(null);

const selectedModel = voiceModels.find((m) => m.id === selectedModelId) || null;

  // Cleanup polling on unmount
  useEffect(() => {
    return () => {
      pollingRefs.current.forEach((_, key) => {
        pollingRefs.current.set(key, false);
      });
    };
  }, []);

  // Add a new empty job
  const addJob = () => {
    setJobs((prev) => [
      ...prev,
      { id: crypto.randomUUID(), script: "", imageId: null, imageUrl: null, status: "pending" },
    ]);
  };

  // Remove a job
  const removeJob = (id: string) => {
    if (jobs.length <= 1) return;
    pollingRefs.current.set(id, false);
    setJobs((prev) => prev.filter((j) => j.id !== id));
  };

  // Update a job field
  const updateJob = (id: string, updates: Partial<BulkJob>) => {
    setJobs((prev) =>
      prev.map((j) => (j.id === id ? { ...j, ...updates } : j))
    );
  };

  // Image picker
  const fetchPickerImages = useCallback(
    async (append: boolean) => {
      setPickerLoading(true);
      const offset = append ? pickerImages.length : 0;
      const result = await getAssetsAction({
        file_type: "image",
        search: pickerSearch || undefined,
        sort_by: "created_at",
        sort_order: "desc",
        limit: 30,
        offset,
      });
      if (append) {
        setPickerImages((prev) => [...prev, ...result.assets]);
      } else {
        setPickerImages(result.assets);
      }
      setPickerTotal(result.total);
      setPickerLoading(false);
    },
    [pickerSearch, pickerImages.length]
  );

  // Load images when picker opens
  useEffect(() => {
    if (pickerJobId) {
      setPickerSearch("");
      fetchPickerImages(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pickerJobId]);

  const handlePickerSearch = (value: string) => {
    setPickerSearch(value);
    const t = setTimeout(() => fetchPickerImages(false), 300);
    return () => clearTimeout(t);
  };

  const handlePickerSelect = (image: AssetWithUrl) => {
    if (pickerJobId) {
      updateJob(pickerJobId, { imageId: image.id, imageUrl: image.signed_url });
      setPickerJobId(null);
    }
  };

  const handlePickerUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file || !file.type.startsWith("image/")) return;
    if (file.size > 50 * 1024 * 1024) {
      toast.error("File exceeds 50MB size limit");
      return;
    }

    setUploading(true);
    try {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("tags", JSON.stringify(["talking-head", "portrait"]));

      const res = await fetch("/api/assets/upload", { method: "POST", body: formData });
      const data = await res.json();

      if (!res.ok) {
        toast.error(data.error || "Upload failed");
        return;
      }

      toast.success("Image uploaded!");
      const result = await getAssetsAction({
        file_type: "image",
        sort_by: "created_at",
        sort_order: "desc",
        limit: 30,
        offset: 0,
      });
      setPickerImages(result.assets);
      setPickerTotal(result.total);

      // Auto-select uploaded
      const uploaded = result.assets.find((a) => a.id === data.asset.id);
      if (uploaded && pickerJobId) {
        updateJob(pickerJobId, { imageId: uploaded.id, imageUrl: uploaded.signed_url });
        setPickerJobId(null);
      }
    } catch {
      toast.error("Failed to upload image");
    } finally {
      setUploading(false);
      if (fileInputRef.current) fileInputRef.current.value = "";
    }
  };


  const handleDragOver = (e, jobId) => {
    e.preventDefault();
    e.stopPropagation();
    if (!running) setDragOverJobId(jobId);
  };

  const handleDragLeave = () => {
    setDragOverJobId(null);
  };

  const handleDrop = async (e, jobId) => {
    e.preventDefault();
    e.stopPropagation();
    setDragOverJobId(null);

    if (running) return;

    const file = e.dataTransfer.files?.[0];
    if (!file || !file.type.startsWith('image/')) {
      toast.error('Only image files are supported');
      return;
    }

    const tempEvent = { target: { files: [file] } };
    await handlePickerUpload(tempEvent);
  };
  
  const handleDragOver = (e, jobId) => {
    e.preventDefault();
    e.stopPropagation();
    if (!running) setDragOverJobId(jobId);
  };

  const handleDragLeave = () => {
    setDragOverJobId(null);
  };

  const handleDrop = async (e, jobId) => {
    e.preventDefault();
    e.stopPropagation();
    setDragOverJobId(null);

    if (running) return;

    const file = e.dataTransfer.files && e.dataTransfer.files[0];
    if (!file || !file.type.startsWith("image/")) {
      toast.error("Only image files are supported");
      return;
    }

    const tempEvent = { target: { files: [file] } };
    await handlePickerUpload(tempEvent);
  };

// Apply same image to all jobs that don't have one
  const applyImageToAll = (imageId: string, imageUrl: string) => {
    setJobs((prev) =>
      prev.map((j) =>
        j.imageId === null ? { ...j, imageId, imageUrl } : j
      )
    );
  };

  // --- Bulk execution ---

  // Caption processing for a single job
  const addCaptionsToJob = useCallback(
    async (jobId: string, videoUrl: string, audioUrl: string) => {
      updateJob(jobId, { status: "captioning" });

      try {
        // 1. Transcribe audio for word timestamps
        const transcribeRes = await fetch("/api/talking-head/transcribe-audio", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ audioUrl }),
        });
        const transcribeData = await transcribeRes.json();

        if (!transcribeRes.ok || !transcribeData.words?.length) {
          // Caption failed but video is still usable
          console.error("Caption transcription failed:", transcribeData.error);
          updateJob(jobId, { status: "completed", videoUrl });
          return;
        }

        // 2. Burn captions into video
        const captionRes = await fetch("/api/talking-head/add-captions", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            videoUrl,
            words: transcribeData.words,
            customSettings: captionSettings,
          }),
        });
        const captionData = await captionRes.json();

        if (!captionRes.ok) {
          // Caption failed but video is still usable
          console.error("Caption burn-in failed:", captionData.error);
          updateJob(jobId, { status: "completed", videoUrl });
          return;
        }

        updateJob(jobId, {
          status: "completed",
          captionedVideoUrl: captionData.signedUrl,
          videoAssetId: captionData.assetId,
        });
      } catch (err) {
        console.error("Caption error:", err);
        // Caption failed but video is still usable
        updateJob(jobId, { status: "completed", videoUrl });
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [captionSettings]
  );

  const pollJob = useCallback(
    async (jobId: string, taskId: string, shouldCaption: boolean, audioSignedUrlForCaption: string) => {
      pollingRefs.current.set(jobId, true);
      let attempts = 0;

      while (pollingRefs.current.get(jobId) && attempts < MAX_POLL_ATTEMPTS) {
        attempts++;
        updateJob(jobId, { pollCount: attempts });

        try {
          const res = await fetch(
            `/api/talking-head/status?taskId=${encodeURIComponent(taskId)}`
          );
          const data = await res.json();

          if (data.status === "completed" && data.videoUrl) {
            pollingRefs.current.set(jobId, false);

            if (shouldCaption) {
              // Run caption pipeline
              addCaptionsToJob(jobId, data.videoUrl, audioSignedUrlForCaption);
            } else {
              updateJob(jobId, { status: "completed", videoUrl: data.videoUrl });
            }
            return;
          }

          if (data.status === "failed") {
            pollingRefs.current.set(jobId, false);
            updateJob(jobId, {
              status: "failed",
              error: data.error || "Video generation failed",
            });
            return;
          }

          await new Promise((r) => setTimeout(r, POLL_INTERVAL_MS));
        } catch {
          pollingRefs.current.set(jobId, false);
          updateJob(jobId, { status: "failed", error: "Network error" });
          return;
        }
      }

      if (pollingRefs.current.get(jobId)) {
        pollingRefs.current.set(jobId, false);
        updateJob(jobId, { status: "failed", error: "Timed out" });
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [addCaptionsToJob]
  );

  const processJob = useCallback(
    async (job: BulkJob, model: AiModelWithImages) => {
      // 1. Generate TTS
      updateJob(job.id, { status: "generating_voice" });
      try {
        const ttsRes = await fetch("/api/tts/generate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            text: job.script,
            voice_id: model.voice_id,
            settings: model.voice_settings,
          }),
        });

        if (!ttsRes.ok) {
          const err = await ttsRes.json().catch(() => ({ error: "TTS failed" }));
          updateJob(job.id, { status: "failed", error: err.error || "TTS failed" });
          return;
        }

        const audioBlob = await ttsRes.blob();
        const blobUrl = URL.createObjectURL(audioBlob);
        updateJob(job.id, { audioUrl: blobUrl });

        // 2. Upload audio
        updateJob(job.id, { status: "uploading_audio" });
        const formData = new FormData();
        formData.append("file", audioBlob, "talking-head-audio.mp3");

        const uploadRes = await fetch("/api/talking-head/upload-audio", {
          method: "POST",
          body: formData,
        });

        const uploadData = await uploadRes.json();
        if (!uploadRes.ok) {
          updateJob(job.id, { status: "failed", error: uploadData.error || "Audio upload failed" });
          return;
        }

        updateJob(job.id, { audioSignedUrl: uploadData.signedUrl });

        // 3. Submit InfiniteTalk
        updateJob(job.id, { status: "submitting" });
        const submitRes = await fetch("/api/talking-head/submit", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            audioSignedUrl: uploadData.signedUrl,
            imageSignedUrl: job.imageUrl,
            resolution,
          }),
        });

        const submitData = await submitRes.json();
        if (!submitRes.ok) {
          updateJob(job.id, { status: "failed", error: submitData.error || "Submit failed" });
          return;
        }

        updateJob(job.id, { status: "polling", taskId: submitData.taskId, pollCount: 0 });

        // 4. Poll (don't await — let it run in background)
        pollJob(job.id, submitData.taskId, captionsEnabled, uploadData.signedUrl);
      } catch (err) {
        updateJob(job.id, {
          status: "failed",
          error: err instanceof Error ? err.message : "Processing failed",
        });
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [resolution, captionsEnabled, pollJob]
  );

  const handleRunAll = async () => {
    if (!selectedModel) {
      toast.error("Select an AI model first");
      return;
    }

    const validJobs = jobs.filter(
      (j) => j.script.trim() && j.imageId && j.imageUrl && j.status === "pending"
    );

    if (validJobs.length === 0) {
      toast.error("No valid jobs to process. Each needs a script and image.");
      return;
    }

    setRunning(true);
    toast.info(`Starting ${validJobs.length} video generation${validJobs.length > 1 ? "s" : ""}...`);

    // Process all jobs in parallel
    for (const job of validJobs) {
      processJob(job, selectedModel);
    }
  };

  const handleSaveVideo = async (jobId: string, videoUrl: string) => {
    try {
      const res = await fetch("/api/talking-head/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ videoUrl }),
      });
      const data = await res.json();
      if (res.ok) {
        updateJob(jobId, { videoAssetId: data.assetId });
        toast.success("Video saved to library!");
      } else {
        toast.error(data.error || "Failed to save");
      }
    } catch {
      toast.error("Failed to save video");
    }
  };

  // Derived stats
  const completedCount = jobs.filter((j) => j.status === "completed").length;
  const failedCount = jobs.filter((j) => j.status === "failed").length;
  const processingCount = jobs.filter(
    (j) =>
      j.status === "generating_voice" ||
      j.status === "uploading_audio" ||
      j.status === "submitting" ||
      j.status === "polling" ||
      j.status === "captioning"
  ).length;
  const allDone = running && processingCount === 0;
  const canRun =
    !running &&
    selectedModelId &&
    jobs.some((j) => j.script.trim() && j.imageId);

  return (
    <div className="space-y-6">
      {/* Shared settings */}
      <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label>AI Model (Voice)</Label>
          {voiceModels.length === 0 ? (
            <Alert>
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>
                No AI models with voice configured.{" "}
                <a href="/dashboard/models" className="underline font-medium">
                  Add voice settings
                </a>
              </AlertDescription>
            </Alert>
          ) : (
            <Select value={selectedModelId} onValueChange={setSelectedModelId}>
              <SelectTrigger>
                <SelectValue placeholder="Select AI model..." />
              </SelectTrigger>
              <SelectContent>
                {voiceModels.map((m) => (
                  <SelectItem key={m.id} value={m.id}>
                    <span className="flex items-center gap-2">
                      {m.reference_images.length > 0 ? (
                        <img
                          src={m.reference_images[0].signed_url}
                          alt=""
                          className="h-5 w-5 rounded-sm object-cover"
                        />
                      ) : (
                        <Mic className="h-3.5 w-3.5 text-muted-foreground" />
                      )}
                      {m.name}
                    </span>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          )}
        </div>

        <div className="space-y-2">
          <Label>Resolution</Label>
          <Select value={resolution} onValueChange={setResolution}>
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="480p">480p — $0.03/sec</SelectItem>
              <SelectItem value="720p">720p — $0.06/sec</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Caption settings */}
      <div className="space-y-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Subtitles className="h-4 w-4 text-muted-foreground" />
            <Label>Add Captions</Label>
          </div>
          <Switch
            checked={captionsEnabled}
            onCheckedChange={setCaptionsEnabled}
            disabled={running}
          />
        </div>

        {captionsEnabled && !running && (
          <CaptionCustomizerInline
            settings={captionSettings}
            onChange={setCaptionSettings}
          />
        )}
      </div>

      {/* Job list */}
      <div className="space-y-3">
        <div className="flex items-center justify-between">
          <Label className="text-base">Videos ({jobs.length})</Label>
          <Button variant="outline" size="sm" onClick={addJob} disabled={running}>
            <Plus className="h-4 w-4 mr-1.5" />
            Add Video
          </Button>
        </div>

        {jobs.map((job, idx) => (
          <div
            key={job.id}
            className={cn(
              "rounded-lg border p-4 space-y-3",
              job.status === "completed" && "border-green-500 bg-green-500/5",
              job.status === "failed" && "border-destructive bg-destructive/5"
            )}
          >
            {/* Header */}
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium">Video {idx + 1}</span>
              <div className="flex items-center gap-2">
                <JobStatusBadge status={job.status} pollCount={job.pollCount} />
                {!running && jobs.length > 1 && (
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => removeJob(job.id)}
                    className="h-7 w-7 p-0"
                  >
                    <Trash2 className="h-3.5 w-3.5" />
                  </Button>
                )}
              </div>
            </div>

            {/* Script + Image row */}
            {job.status === "pending" && (
              <div className="grid grid-cols-1 sm:grid-cols-[1fr_auto] gap-3">
                <div className="space-y-1.5">
                  <Label className="text-xs">Script</Label>
                  <Textarea
                    value={job.script}
                    onChange={(e) => updateJob(job.id, { script: e.target.value })}
                    placeholder="Paste the script for this video..."
                    rows={4}
                    className="resize-y text-sm"
                    disabled={running}
                  />
                  <span className="text-xs text-muted-foreground">
                    {job.script.trim().split(/\s+/).filter(Boolean).length} words
                  </span>
                </div>

                <div className="space-y-1.5">
                  <Label className="text-xs">Portrait</Label>
                  {job.imageUrl ? (
                    <div className="relative group">
                      <img
                        src={job.imageUrl}
                        alt="Selected"
                        className="h-[106px] w-[106px] rounded-md object-cover border cursor-pointer"
                        onClick={() => !running && setPickerJobId(job.id)}
                      />
                      {!running && (
                        <button
                          type="button"
                          onClick={() =>
                            updateJob(job.id, { imageId: null, imageUrl: null })
                          }
                          className="absolute -top-1.5 -right-1.5 h-5 w-5 rounded-full bg-destructive text-destructive-foreground flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
                        >
                          <X className="h-3 w-3" />
                        </button>
                      )}
                    </div>
                  ) : (
                    <button
                      type="button"
                      onClick={() => setPickerJobId(job.id)}
                      disabled={running}
                      className="h-[106px] w-[106px] rounded-md border-2 border-dashed flex flex-col items-center justify-center gap-1 text-muted-foreground hover:border-accent-blue/50 hover:text-accent-blue transition-colors"
                    >
                      <ImageIcon className="h-5 w-5" />
                      <span className="text-[10px]">Select</span>
                    </button>
                  )}
                </div>
              </div>
            )}

            {/* Processing status */}
            {job.status !== "pending" && job.status !== "completed" && job.status !== "failed" && (
              <div className="space-y-2">
                <div className="flex items-center gap-2">
                  <Loader2 className="h-3.5 w-3.5 animate-spin text-accent-blue" />
                  <span className="text-xs">
                    {job.status === "generating_voice" && "Generating voice..."}
                    {job.status === "uploading_audio" && "Uploading audio..."}
                    {job.status === "submitting" && "Submitting video job..."}
                    {job.status === "polling" &&
                      `Generating video... ${Math.round((job.pollCount || 0) * 3)}s`}
                    {job.status === "captioning" && "Adding captions..."}
                  </span>
                </div>
                {job.status === "polling" && (
                  <Progress
                    value={Math.min(((job.pollCount || 0) / MAX_POLL_ATTEMPTS) * 100, 95)}
                    className="h-1.5"
                  />
                )}
              </div>
            )}

            {/* Error */}
            {job.status === "failed" && job.error && (
              <p className="text-xs text-destructive">{job.error}</p>
            )}

            {/* Completed — video actions */}
            {job.status === "completed" && (job.captionedVideoUrl || job.videoUrl) && (
              <div className="space-y-2">
                {job.captionedVideoUrl && (
                  <Badge variant="secondary" className="gap-1 text-xs mb-1">
                    <Subtitles className="h-3 w-3" />
                    Captioned
                  </Badge>
                )}
                <video
                  controls
                  src={job.captionedVideoUrl || job.videoUrl}
                  className="w-full max-h-[200px] rounded-md bg-black"
                  preload="metadata"
                />
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => {
                      const a = document.createElement("a");
                      a.href = (job.captionedVideoUrl || job.videoUrl)!;
                      a.download = `talking-head-${idx + 1}.mp4`;
                      a.target = "_blank";
                      a.click();
                    }}
                  >
                    <Download className="h-3.5 w-3.5 mr-1" />
                    Download
                  </Button>
                  {job.videoAssetId ? (
                    <Badge variant="secondary" className="gap-1">
                      <CheckCircle2 className="h-3 w-3" />
                      Saved
                    </Badge>
                  ) : (
                    <Button
                      size="sm"
                      onClick={() => handleSaveVideo(job.id, (job.captionedVideoUrl || job.videoUrl)!)}
                    >
                      <Save className="h-3.5 w-3.5 mr-1" />
                      Save to Library
                    </Button>
                  )}
                </div>
              </div>
            )}
          </div>
        ))}
      </div>

      {/* Progress summary */}
      {running && (
        <div className="flex items-center gap-3 text-sm">
          {processingCount > 0 && (
            <Badge variant="secondary">
              <Loader2 className="h-3 w-3 mr-1 animate-spin" />
              {processingCount} processing
            </Badge>
          )}
          {completedCount > 0 && (
            <Badge variant="secondary" className="text-green-600">
              <CheckCircle2 className="h-3 w-3 mr-1" />
              {completedCount} completed
            </Badge>
          )}
          {failedCount > 0 && (
            <Badge variant="destructive">
              <AlertCircle className="h-3 w-3 mr-1" />
              {failedCount} failed
            </Badge>
          )}
        </div>
      )}

      {/* Run button */}
      <div className="flex gap-2">
        <Button
          onClick={handleRunAll}
          disabled={!canRun}
          size="lg"
          className="flex-1"
        >
          <Video className="h-4 w-4 mr-2" />
          {running
            ? allDone
              ? "All Done"
              : `Processing ${processingCount} video${processingCount !== 1 ? "s" : ""}...`
            : `Generate ${jobs.filter((j) => j.script.trim() && j.imageId).length} Video${jobs.filter((j) => j.script.trim() && j.imageId).length !== 1 ? "s" : ""}`}
        </Button>

        {allDone && (
          <Button
            variant="outline"
            size="lg"
            onClick={() => {
              setRunning(false);
              setJobs([
                { id: crypto.randomUUID(), script: "", imageId: null, imageUrl: null, status: "pending" },
              ]);
            }}
          >
            Start New Batch
          </Button>
        )}
      </div>

      {/* Image picker dialog */}
      <Dialog open={pickerJobId !== null} onOpenChange={(open) => !open && setPickerJobId(null)}>
        <DialogContent className="max-w-2xl max-h-[80vh] flex flex-col">
          <DialogHeader>
            <DialogTitle>Select Portrait Image</DialogTitle>
          </DialogHeader>

          <div className="flex items-center gap-2">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search images..."
                value={pickerSearch}
                onChange={(e) => handlePickerSearch(e.target.value)}
                className="pl-9"
              />
            </div>
            <input
              ref={fileInputRef}
              type="file"
              accept="image/*"
              onChange={handlePickerUpload}
              className="hidden"
            />
            <Button
              variant="outline"
              size="sm"
              onClick={() => fileInputRef.current?.click()}
              disabled={uploading}
            >
              {uploading ? (
                <Loader2 className="h-4 w-4 mr-1 animate-spin" />
              ) : (
                <Upload className="h-4 w-4 mr-1" />
              )}
              Upload
            </Button>
          </div>

          {/* Model images shortcut */}
          {selectedModel && selectedModel.reference_images.length > 0 && (
            <div>
              <p className="text-xs font-medium mb-1.5">
                {selectedModel.name}&apos;s Reference Images
              </p>
              <div className="flex gap-1.5 overflow-x-auto pb-1">
                {selectedModel.reference_images.map((img) => (
                  <button
                    key={img.id}
                    type="button"
                    className="h-14 w-14 rounded-md overflow-hidden border-2 border-transparent hover:border-accent-blue/50 transition-all flex-shrink-0"
                    onClick={() => handlePickerSelect(img)}
                  >
                    <img
                      src={img.signed_url}
                      alt=""
                      className="h-full w-full object-cover"
                    />
                  </button>
                ))}
              </div>
            </div>
          )}

          <div className="flex-1 overflow-y-auto min-h-0">
            {pickerImages.length === 0 && !pickerLoading ? (
              <div className="flex items-center justify-center py-8">
                <p className="text-sm text-muted-foreground">No images found.</p>
              </div>
            ) : (
              <div className="grid grid-cols-4 sm:grid-cols-5 gap-2 pb-2">
                {pickerImages.map((image) => (
                  <button
                    key={image.id}
                    type="button"
                    className="relative aspect-square overflow-hidden rounded-md border-2 border-transparent hover:border-accent-blue/50 transition-all"
                    onClick={() => handlePickerSelect(image)}
                  >
                    <img
                      src={image.signed_url}
                      alt={image.filename}
                      className="h-full w-full object-cover"
                      loading="lazy"
                    />
                  </button>
                ))}
              </div>
            )}

            {pickerImages.length < pickerTotal && (
              <div className="flex justify-center py-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => fetchPickerImages(true)}
                  disabled={pickerLoading}
                >
                  {pickerLoading ? <Loader2 className="h-4 w-4 animate-spin" /> : "Load More"}
                </Button>
              </div>
            )}
          </div>

          {/* Apply to all button */}
          {pickerJobId && (
            <p className="text-xs text-muted-foreground">
              Click an image to select it for this video. Uploaded images are auto-saved to your asset library.
            </p>
          )}
        </DialogContent>
      </Dialog>
    </div>
  );
}

// --- Helper component ---

function JobStatusBadge({
  status,
  pollCount,
}: {
  status: BulkJob["status"];
  pollCount?: number;
}) {
  switch (status) {
    case "pending":
      return (
        <Badge variant="outline" className="text-xs">
          Pending
        </Badge>
      );
    case "generating_voice":
      return (
        <Badge variant="secondary" className="text-xs gap-1">
          <Loader2 className="h-3 w-3 animate-spin" />
          Voice
        </Badge>
      );
    case "uploading_audio":
      return (
        <Badge variant="secondary" className="text-xs gap-1">
          <Loader2 className="h-3 w-3 animate-spin" />
          Upload
        </Badge>
      );
    case "submitting":
      return (
        <Badge variant="secondary" className="text-xs gap-1">
          <Loader2 className="h-3 w-3 animate-spin" />
          Submit
        </Badge>
      );
    case "polling":
      return (
        <Badge variant="secondary" className="text-xs gap-1">
          <Loader2 className="h-3 w-3 animate-spin" />
          {Math.round((pollCount || 0) * 3)}s
        </Badge>
      );
    case "captioning":
      return (
        <Badge variant="secondary" className="text-xs gap-1">
          <Loader2 className="h-3 w-3 animate-spin" />
          Captions
        </Badge>
      );
    case "completed":
      return (
        <Badge variant="secondary" className="text-xs gap-1 text-green-600">
          <CheckCircle2 className="h-3 w-3" />
          Done
        </Badge>
      );
    case "failed":
      return (
        <Badge variant="destructive" className="text-xs gap-1">
          <AlertCircle className="h-3 w-3" />
          Failed
        </Badge>
      );
  }
}
