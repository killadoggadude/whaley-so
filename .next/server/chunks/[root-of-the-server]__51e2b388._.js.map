{"version":3,"sources":["../../../src/lib/crypto.ts","../../../src/lib/api-keys.ts"],"sourcesContent":["import crypto from \"crypto\";\n\nconst ALGORITHM = \"aes-256-gcm\";\nconst IV_LENGTH = 16;\nconst AUTH_TAG_LENGTH = 16;\n\nfunction getEncryptionKey(): Buffer {\n  const secret = process.env.API_KEY_ENCRYPTION_SECRET;\n  if (!secret) {\n    throw new Error(\"API_KEY_ENCRYPTION_SECRET is not set\");\n  }\n  return Buffer.from(secret, \"hex\");\n}\n\n/**\n * Encrypt a plaintext string using AES-256-GCM.\n * Returns format: iv:authTag:ciphertext (hex-encoded, colon-separated)\n */\nexport function encrypt(plaintext: string): string {\n  const key = getEncryptionKey();\n  const iv = crypto.randomBytes(IV_LENGTH);\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n\n  let encrypted = cipher.update(plaintext, \"utf8\", \"hex\");\n  encrypted += cipher.final(\"hex\");\n\n  const authTag = cipher.getAuthTag();\n\n  return `${iv.toString(\"hex\")}:${authTag.toString(\"hex\")}:${encrypted}`;\n}\n\n/**\n * Decrypt a string encrypted with encrypt().\n * Input format: iv:authTag:ciphertext (hex-encoded, colon-separated)\n */\nexport function decrypt(encryptedData: string): string {\n  const key = getEncryptionKey();\n  const parts = encryptedData.split(\":\");\n\n  if (parts.length !== 3) {\n    throw new Error(\"Invalid encrypted data format\");\n  }\n\n  const iv = Buffer.from(parts[0], \"hex\");\n  const authTag = Buffer.from(parts[1], \"hex\");\n  const encrypted = parts[2];\n\n  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n  decipher.setAuthTag(authTag);\n\n  let decrypted = decipher.update(encrypted, \"hex\", \"utf8\");\n  decrypted += decipher.final(\"utf8\");\n\n  return decrypted;\n}\n\n/**\n * Mask an API key, showing only the last 4 characters.\n * e.g., \"sk-abc123xyz789\" → \"••••••••••789\"\n */\nexport function maskApiKey(apiKey: string): string {\n  if (apiKey.length <= 4) {\n    return \"••••\";\n  }\n  return \"••••••••••\" + apiKey.slice(-4);\n}\n","import { createClient } from \"@/lib/supabase/server\";\nimport { encrypt, decrypt, maskApiKey } from \"@/lib/crypto\";\nimport type { ApiService, MaskedApiKey } from \"@/types\";\n\n/**\n * Get all API keys for the current user, masked for display.\n * Only returns service name, masked key, and timestamps.\n */\nexport async function getMaskedKeys(): Promise<MaskedApiKey[]> {\n  const supabase = await createClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error(\"Not authenticated\");\n  }\n\n  const { data, error } = await supabase\n    .from(\"user_api_keys\")\n    .select(\"service, encrypted_api_key, created_at, updated_at\")\n    .eq(\"user_id\", user.id);\n\n  if (error) {\n    throw new Error(`Failed to fetch API keys: ${error.message}`);\n  }\n\n  return (data || []).map((row) => ({\n    service: row.service as ApiService,\n    masked_key: maskApiKey(decrypt(row.encrypted_api_key)),\n    created_at: row.created_at,\n    updated_at: row.updated_at,\n  }));\n}\n\n/**\n * Get a decrypted API key for a specific service.\n * Server-side only — never expose to client.\n */\nexport async function getDecryptedKey(\n  service: ApiService\n): Promise<string | null> {\n  const supabase = await createClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error(\"Not authenticated\");\n  }\n\n  const { data, error } = await supabase\n    .from(\"user_api_keys\")\n    .select(\"encrypted_api_key\")\n    .eq(\"user_id\", user.id)\n    .eq(\"service\", service)\n    .single();\n\n  if (error || !data) {\n    return null;\n  }\n\n  return decrypt(data.encrypted_api_key);\n}\n\n/**\n * Insert or update an API key for the current user.\n * Encrypts the key before storing.\n */\nexport async function upsertApiKey(\n  service: ApiService,\n  apiKey: string\n): Promise<void> {\n  const supabase = await createClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error(\"Not authenticated\");\n  }\n\n  const encryptedKey = encrypt(apiKey);\n\n  // Check if key already exists for this service\n  const { data: existing } = await supabase\n    .from(\"user_api_keys\")\n    .select(\"id\")\n    .eq(\"user_id\", user.id)\n    .eq(\"service\", service)\n    .single();\n\n  if (existing) {\n    const { error } = await supabase\n      .from(\"user_api_keys\")\n      .update({ encrypted_api_key: encryptedKey })\n      .eq(\"user_id\", user.id)\n      .eq(\"service\", service);\n\n    if (error) {\n      throw new Error(`Failed to update API key: ${error.message}`);\n    }\n  } else {\n    const { error } = await supabase.from(\"user_api_keys\").insert({\n      user_id: user.id,\n      service,\n      encrypted_api_key: encryptedKey,\n    });\n\n    if (error) {\n      throw new Error(`Failed to save API key: ${error.message}`);\n    }\n  }\n}\n\n/**\n * Delete an API key for the current user.\n */\nexport async function deleteApiKey(service: ApiService): Promise<void> {\n  const supabase = await createClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    throw new Error(\"Not authenticated\");\n  }\n\n  const { error } = await supabase\n    .from(\"user_api_keys\")\n    .delete()\n    .eq(\"user_id\", user.id)\n    .eq(\"service\", service);\n\n  if (error) {\n    throw new Error(`Failed to delete API key: ${error.message}`);\n  }\n}\n"],"names":[],"mappings":"kjCAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OAEA,IAAM,EAAY,cAIlB,SAAS,IACP,IAAM,EAAS,QAAQ,GAAG,CAAC,yBAAyB,CACpD,GAAI,CAAC,EACH,MAAM,AADK,AACD,MAAM,wCAElB,OAAO,OAAO,IAAI,CAAC,EAAQ,MAC7B,CAMO,SAAS,EAAQ,CAAiB,EACvC,IAAM,EAAM,IACN,EAAK,EAAA,OAAM,CAAC,WAAW,CAjBb,AAiBc,IACxB,EAAS,EAAA,OAAM,CAAC,cAAc,CAAC,EAAW,EAAK,GAEjD,EAAY,EAAO,MAAM,CAAC,EAAW,OAAQ,OACjD,GAAa,EAAO,KAAK,CAAC,OAE1B,IAAM,EAAU,EAAO,UAAU,GAEjC,MAAO,CAAA,EAAG,EAAG,QAAQ,CAAC,OAAO,CAAC,EAAE,EAAQ,QAAQ,CAAC,OAAO,CAAC,EAAE,EAAA,CAAW,AACxE,CAMO,SAAS,EAAQ,CAAqB,EAC3C,IAAM,EAAM,IACN,EAAQ,EAAc,KAAK,CAAC,KAElC,GAAqB,GAAG,CAApB,EAAM,MAAM,CACd,MAAU,AAAJ,MAAU,iCAGlB,IAAM,EAAK,OAAO,IAAI,CAAC,CAAK,CAAC,EAAE,CAAE,OAC3B,EAAU,OAAO,IAAI,CAAC,CAAK,CAAC,EAAE,CAAE,OAChC,EAAY,CAAK,CAAC,EAAE,CAEpB,EAAW,EAAA,OAAM,CAAC,gBAAgB,CAAC,EAAW,EAAK,GACzD,EAAS,UAAU,CAAC,GAEpB,IAAI,EAAY,EAAS,MAAM,CAAC,EAAW,MAAO,QAGlD,OAFA,AAEO,EAFM,EAAS,KAAK,CAAC,OAG9B,gECtDA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OAsCO,eAAe,EACpB,CAAmB,EAEnB,IAAM,EAAW,MAAM,CAAA,EAAA,EAAA,YAAA,AAAY,IAC7B,CACJ,KAAM,MAAE,CAAI,CAAE,CACf,CAAG,MAAM,EAAS,IAAI,CAAC,OAAO,GAE/B,GAAI,CAAC,EACH,IADS,EACH,AAAI,MAAM,qBAGlB,GAAM,MAAE,CAAI,OAAE,CAAK,CAAE,CAAG,MAAM,EAC3B,IAAI,CAAC,iBACL,MAAM,CAAC,qBACP,EAAE,CAAC,UAAW,EAAK,EAAE,EACrB,EAAE,CAAC,UAAW,GACd,MAAM,UAET,AAAI,GAAS,CAAC,EACL,IADW,CAIb,CAAA,EAAA,EAAA,OAAA,AAAO,EAAC,EAAK,iBAAiB,CACvC"}